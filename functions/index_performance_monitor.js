/**
 * Index Performance Monitoring System
 * Task 3.2: Ïù∏Îç±Ïä§ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú
 * 
 * ÏÉùÏÑ±Îêú Ïù∏Îç±Ïä§Ïùò ÏÑ±Îä•ÏùÑ Ïã§ÏãúÍ∞ÑÏúºÎ°ú Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥†
 * ÏÑ±Îä• Í∞úÏÑ† Ìö®Í≥ºÎ•º Ï∏°Ï†ïÌïòÎ©∞ Î≥¥Í≥†ÏÑúÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */

const mysql = require('mysql2/promise');
const MetricsCollector = require('./src/monitoring/MetricsCollector');
const AlertSystem = require('./src/monitoring/AlertSystem');
require('dotenv').config();

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ§Ï†ï
const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT || 3306,
  ssl: false
};

// Task 3.1ÏóêÏÑú ÏÉùÏÑ±Îêú Ïù∏Îç±Ïä§ Î™©Î°ù
const MONITORED_INDEXES = [
  {
    name: 'idx_game_scores_userId',
    table: 'game_scores',
    columns: ['userId'],
    priority: 'CRITICAL',
    targetQueries: ['JOIN with players table']
  },
  {
    name: 'idx_players_status_userId',
    table: 'players',
    columns: ['status', 'userId'],
    priority: 'HIGH',
    targetQueries: ['WHERE status filters']
  },
  {
    name: 'idx_game_scores_userId_gameDate',
    table: 'game_scores',
    columns: ['userId', 'gameDate'],
    priority: 'HIGH',
    targetQueries: ['Date range queries']
  },
  {
    name: 'idx_promotion_players_player_appliedAt',
    table: 'promotion_players',
    columns: ['player', 'appliedAt'],
    priority: 'MEDIUM',
    targetQueries: ['Event analysis queries']
  },
  {
    name: 'idx_money_flows_player_type_createdAt',
    table: 'money_flows',
    columns: ['player', 'type', 'createdAt'],
    priority: 'MEDIUM',
    targetQueries: ['Financial transaction analysis']
  },
  {
    name: 'idx_player_guilds_guild_player',
    table: 'player_guilds',
    columns: ['guild', 'player'],
    priority: 'MEDIUM',
    targetQueries: ['Multi-account analysis']
  }
];

// ÏÑ±Îä• ÌÖåÏä§Ìä∏ ÏøºÎ¶¨ Î™©Î°ù
const PERFORMANCE_TEST_QUERIES = [
  {
    id: 'critical_join',
    name: 'Critical JOIN Query',
    sql: `SELECT p.userId, COUNT(gs.gameDate) as gameDays, 
          SUM(gs.netBet) as totalBet
          FROM players p 
          LEFT JOIN game_scores gs ON p.userId = gs.userId 
          WHERE p.status = 0 
          GROUP BY p.userId 
          LIMIT 100`,
    targetTime: 100,
    relatedIndex: 'idx_game_scores_userId',
    category: 'JOIN'
  },
  {
    id: 'date_range',
    name: 'Date Range Query',
    sql: `SELECT userId, SUM(netBet) as totalBet
          FROM game_scores 
          WHERE gameDate >= '2024-01-01' AND gameDate <= '2024-12-31'
          GROUP BY userId 
          LIMIT 50`,
    targetTime: 50,
    relatedIndex: 'idx_game_scores_userId_gameDate',
    category: 'DATE_RANGE'
  },
  {
    id: 'event_analysis',
    name: 'Event Analysis Query',
    sql: `SELECT COUNT(*) as eventParticipants
          FROM promotion_players 
          WHERE appliedAt IS NOT NULL 
          AND appliedAt >= '2024-01-01'`,
    targetTime: 30,
    relatedIndex: 'idx_promotion_players_player_appliedAt',
    category: 'ANALYSIS'
  },
  {
    id: 'user_status_filter',
    name: 'User Status Filter',
    sql: `SELECT userId, status FROM players 
          WHERE status = 0 
          ORDER BY userId 
          LIMIT 100`,
    targetTime: 25,
    relatedIndex: 'idx_players_status_userId',
    category: 'FILTER'
  },
  {
    id: 'financial_analysis',
    name: 'Financial Transaction Analysis',
    sql: `SELECT player, type, COUNT(*) as transactions, 
          SUM(amount) as totalAmount
          FROM money_flows 
          WHERE type IN (0, 1, 2) 
          AND createdAt >= '2024-01-01'
          GROUP BY player, type
          LIMIT 100`,
    targetTime: 75,
    relatedIndex: 'idx_money_flows_player_type_createdAt',
    category: 'FINANCIAL'
  }
];

class IndexPerformanceMonitor {
  constructor() {
    this.connection = null;
    this.metricsCollector = new MetricsCollector();
    this.alertSystem = new AlertSystem();
    
    this.performanceHistory = new Map();
    this.indexUsageStats = new Map();
    this.alertThresholds = {
      slowQueryTime: 200,        // 200ms Ïù¥ÏÉÅÏù¥Î©¥ ÎäêÎ¶∞ ÏøºÎ¶¨
      performanceDegradation: 50, // 50% Ïù¥ÏÉÅ ÏÑ±Îä• Ï†ÄÌïòÏãú ÏïåÎ¶º
      indexNotUsed: 24 * 60 * 60 * 1000 // 24ÏãúÍ∞Ñ ÎèôÏïà ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏúºÎ©¥ ÏïåÎ¶º
    };
    
    this.monitoringStats = {
      totalChecks: 0,
      slowQueries: 0,
      indexHits: 0,
      indexMisses: 0,
      alerts: 0,
      lastCheck: null
    };
    
    console.log('IndexPerformanceMonitor initialized');
  }

  async connect() {
    try {
      this.connection = await mysql.createConnection(dbConfig);
      console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ');
      return true;
    } catch (error) {
      console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®:', error.message);
      return false;
    }
  }

  async disconnect() {
    if (this.connection) {
      await this.connection.end();
      console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¢ÖÎ£å');
    }
  }

  /**
   * Ïù∏Îç±Ïä§ ÏÇ¨Ïö©Î•† ÌÜµÍ≥Ñ ÏàòÏßë
   */
  async collectIndexUsageStats() {
    try {
      console.log('üìä Ïù∏Îç±Ïä§ ÏÇ¨Ïö©Î•† ÌÜµÍ≥Ñ ÏàòÏßë Ï§ë...');
      
      for (const index of MONITORED_INDEXES) {
        // Ïù∏Îç±Ïä§ ÌÜµÍ≥Ñ Ï°∞Ìöå
        const [stats] = await this.connection.execute(
          `SELECT 
            INDEX_NAME, 
            CARDINALITY,
            SEQ_IN_INDEX,
            COLUMN_NAME
           FROM INFORMATION_SCHEMA.STATISTICS 
           WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? AND INDEX_NAME = ?`,
          [process.env.DB_NAME, index.table, index.name]
        );
        
        if (stats.length > 0) {
          this.indexUsageStats.set(index.name, {
            cardinality: stats[0].CARDINALITY,
            columns: stats.map(s => s.COLUMN_NAME),
            lastChecked: new Date(),
            status: 'ACTIVE'
          });
          
          console.log(`‚úÖ ${index.name}: Cardinality ${stats[0].CARDINALITY}`);
        } else {
          console.log(`‚ö†Ô∏è ${index.name}: ÌÜµÍ≥Ñ Ï†ïÎ≥¥ ÏóÜÏùå`);
          this.indexUsageStats.set(index.name, {
            status: 'NOT_FOUND',
            lastChecked: new Date()
          });
        }
      }
      
    } catch (error) {
      console.error('‚ùå Ïù∏Îç±Ïä§ ÌÜµÍ≥Ñ ÏàòÏßë Ïã§Ìå®:', error.message);
    }
  }

  /**
   * ÏøºÎ¶¨ Ïã§Ìñâ Í≥ÑÌöç Î∂ÑÏÑù
   */
  async analyzeQueryPlan(sql, queryId) {
    try {
      const [plan] = await this.connection.execute(`EXPLAIN ${sql}`);
      
      const analysis = {
        queryId,
        timestamp: new Date(),
        usedIndexes: [],
        fullTableScans: 0,
        estimatedRows: 0,
        performance: 'UNKNOWN'
      };
      
      for (const row of plan) {
        if (row.key) {
          analysis.usedIndexes.push(row.key);
          this.monitoringStats.indexHits++;
        } else {
          analysis.fullTableScans++;
          this.monitoringStats.indexMisses++;
        }
        
        analysis.estimatedRows += row.rows || 0;
      }
      
      // ÏÑ±Îä• Îì±Í∏â ÌåêÏ†ï
      if (analysis.fullTableScans === 0 && analysis.usedIndexes.length > 0) {
        analysis.performance = 'EXCELLENT';
      } else if (analysis.fullTableScans <= 1) {
        analysis.performance = 'GOOD';
      } else {
        analysis.performance = 'POOR';
      }
      
      return analysis;
      
    } catch (error) {
      console.error(`‚ùå ÏøºÎ¶¨ Ïã§Ìñâ Í≥ÑÌöç Î∂ÑÏÑù Ïã§Ìå® (${queryId}):`, error.message);
      return null;
    }
  }

  /**
   * ÏÑ±Îä• ÌÖåÏä§Ìä∏ Ïã§Ìñâ
   */
  async runPerformanceTests() {
    console.log('\nüèÉ‚Äç‚ôÇÔ∏è Ïù∏Îç±Ïä§ ÏÑ±Îä• ÌÖåÏä§Ìä∏ Ïã§Ìñâ...');
    
    const results = [];
    
    for (const testQuery of PERFORMANCE_TEST_QUERIES) {
      try {
        console.log(`\nüîç ÌÖåÏä§Ìä∏: ${testQuery.name}`);
        
        // ÏøºÎ¶¨ Ïã§Ìñâ Í≥ÑÌöç Î∂ÑÏÑù
        const planAnalysis = await this.analyzeQueryPlan(testQuery.sql, testQuery.id);
        
        // Ïã§Ìñâ ÏãúÍ∞Ñ Ï∏°Ï†ï
        const startTime = Date.now();
        await this.connection.execute(testQuery.sql);
        const executionTime = Date.now() - startTime;
        
        // Í≤∞Í≥º Î∂ÑÏÑù
        const result = {
          queryId: testQuery.id,
          name: testQuery.name,
          executionTime,
          targetTime: testQuery.targetTime,
          relatedIndex: testQuery.relatedIndex,
          category: testQuery.category,
          planAnalysis,
          status: this.getPerformanceStatus(executionTime, testQuery.targetTime),
          improvement: this.calculateImprovement(testQuery.id, executionTime),
          timestamp: new Date()
        };
        
        results.push(result);
        
        // ÏÑ±Îä• ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•
        if (!this.performanceHistory.has(testQuery.id)) {
          this.performanceHistory.set(testQuery.id, []);
        }
        this.performanceHistory.get(testQuery.id).push({
          executionTime,
          timestamp: new Date()
        });
        
        // ÏÉÅÌÉú Ï∂úÎ†•
        const statusIcon = this.getStatusIcon(result.status);
        console.log(`${statusIcon} ${testQuery.name}: ${executionTime}ms (Î™©Ìëú: ${testQuery.targetTime}ms)`);
        
        if (planAnalysis && planAnalysis.usedIndexes.length > 0) {
          console.log(`   üìä ÏÇ¨Ïö©Îêú Ïù∏Îç±Ïä§: ${planAnalysis.usedIndexes.join(', ')}`);
          console.log(`   üìà ÏÑ±Îä• Îì±Í∏â: ${planAnalysis.performance}`);
        }
        
        // Ïä¨Î°úÏö∞ ÏøºÎ¶¨ Í∞êÏßÄ
        if (executionTime > this.alertThresholds.slowQueryTime) {
          this.monitoringStats.slowQueries++;
          await this.alertSystem.sendAlert({
            type: 'SLOW_QUERY',
            severity: 'WARNING',
            message: `Ïä¨Î°úÏö∞ ÏøºÎ¶¨ Í∞êÏßÄ: ${testQuery.name} (${executionTime}ms)`,
            details: { queryId: testQuery.id, executionTime, targetTime: testQuery.targetTime }
          });
        }
        
      } catch (error) {
        console.error(`‚ùå ${testQuery.name} ÌÖåÏä§Ìä∏ Ïã§Ìå®:`, error.message);
        results.push({
          queryId: testQuery.id,
          name: testQuery.name,
          status: 'ERROR',
          error: error.message,
          timestamp: new Date()
        });
      }
    }
    
    this.monitoringStats.totalChecks++;
    this.monitoringStats.lastCheck = new Date();
    
    return results;
  }

  /**
   * ÏÑ±Îä• ÏÉÅÌÉú ÌåêÏ†ï
   */
  getPerformanceStatus(executionTime, targetTime) {
    if (executionTime <= targetTime) return 'EXCELLENT';
    if (executionTime <= targetTime * 1.5) return 'GOOD';
    if (executionTime <= targetTime * 2) return 'FAIR';
    return 'POOR';
  }

  /**
   * ÏÉÅÌÉú ÏïÑÏù¥ÏΩò Î∞òÌôò
   */
  getStatusIcon(status) {
    const icons = {
      'EXCELLENT': 'üöÄ',
      'GOOD': '‚úÖ',
      'FAIR': '‚ö†Ô∏è',
      'POOR': 'üö®',
      'ERROR': '‚ùå'
    };
    return icons[status] || '‚ùì';
  }

  /**
   * ÏÑ±Îä• Í∞úÏÑ†Î•† Í≥ÑÏÇ∞
   */
  calculateImprovement(queryId, currentTime) {
    const history = this.performanceHistory.get(queryId);
    if (!history || history.length < 2) return null;
    
    const previousTime = history[history.length - 2].executionTime;
    const improvement = ((previousTime - currentTime) / previousTime) * 100;
    
    return {
      previousTime,
      currentTime,
      improvementPercent: Math.round(improvement * 100) / 100
    };
  }

  /**
   * Ïù∏Îç±Ïä§ Ìö®Í≥º Î∂ÑÏÑù Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
   */
  generateIndexEffectivenessReport() {
    console.log('\nüìã Ïù∏Îç±Ïä§ Ìö®Í≥º Î∂ÑÏÑù Î≥¥Í≥†ÏÑú');
    console.log('='.repeat(60));
    
    const report = {
      summary: {
        totalIndexes: MONITORED_INDEXES.length,
        activeIndexes: 0,
        effectiveIndexes: 0,
        totalChecks: this.monitoringStats.totalChecks,
        slowQueries: this.monitoringStats.slowQueries,
        indexHitRate: 0
      },
      indexDetails: [],
      queryPerformance: [],
      recommendations: []
    };
    
    // Ïù∏Îç±Ïä§Î≥Ñ Ìö®Í≥º Î∂ÑÏÑù
    console.log('\nüîç Ïù∏Îç±Ïä§Î≥Ñ Ìö®Í≥º Î∂ÑÏÑù:');
    for (const index of MONITORED_INDEXES) {
      const usage = this.indexUsageStats.get(index.name);
      const relatedQueries = PERFORMANCE_TEST_QUERIES.filter(q => q.relatedIndex === index.name);
      
      let effectiveness = 'UNKNOWN';
      let avgPerformance = 0;
      
      if (relatedQueries.length > 0) {
        const performances = relatedQueries.map(q => {
          const history = this.performanceHistory.get(q.id);
          return history && history.length > 0 ? history[history.length - 1].executionTime : null;
        }).filter(p => p !== null);
        
        if (performances.length > 0) {
          avgPerformance = performances.reduce((a, b) => a + b, 0) / performances.length;
          
          if (avgPerformance <= 50) effectiveness = 'EXCELLENT';
          else if (avgPerformance <= 100) effectiveness = 'GOOD';
          else if (avgPerformance <= 200) effectiveness = 'FAIR';
          else effectiveness = 'POOR';
        }
      }
      
      const indexDetail = {
        name: index.name,
        table: index.table,
        priority: index.priority,
        effectiveness,
        avgPerformance,
        relatedQueriesCount: relatedQueries.length,
        usage: usage || { status: 'UNKNOWN' }
      };
      
      report.indexDetails.push(indexDetail);
      
      if (usage && usage.status === 'ACTIVE') {
        report.summary.activeIndexes++;
        if (effectiveness === 'EXCELLENT' || effectiveness === 'GOOD') {
          report.summary.effectiveIndexes++;
        }
      }
      
      const effectIcon = this.getStatusIcon(effectiveness);
      console.log(`${effectIcon} ${index.name} (${index.priority}): ${effectiveness}`);
      if (avgPerformance > 0) {
        console.log(`   ÌèâÍ∑† ÏÑ±Îä•: ${Math.round(avgPerformance)}ms`);
      }
    }
    
    // ÌûàÌä∏Ïú® Í≥ÑÏÇ∞
    const totalIndexOperations = this.monitoringStats.indexHits + this.monitoringStats.indexMisses;
    if (totalIndexOperations > 0) {
      report.summary.indexHitRate = Math.round((this.monitoringStats.indexHits / totalIndexOperations) * 100);
    }
    
    // ÏøºÎ¶¨ ÏÑ±Îä• ÏöîÏïΩ
    console.log('\nüìä ÏøºÎ¶¨ ÏÑ±Îä• ÏöîÏïΩ:');
    for (const [queryId, history] of this.performanceHistory) {
      if (history.length > 0) {
        const latest = history[history.length - 1];
        const testQuery = PERFORMANCE_TEST_QUERIES.find(q => q.id === queryId);
        
        if (testQuery) {
          const status = this.getPerformanceStatus(latest.executionTime, testQuery.targetTime);
          const statusIcon = this.getStatusIcon(status);
          
          console.log(`${statusIcon} ${testQuery.name}: ${latest.executionTime}ms`);
          
          report.queryPerformance.push({
            queryId,
            name: testQuery.name,
            latestTime: latest.executionTime,
            targetTime: testQuery.targetTime,
            status
          });
        }
      }
    }
    
    // Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
    console.log('\nüìà Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ ÌÜµÍ≥Ñ:');
    console.log(`   Ï¥ù Ïù∏Îç±Ïä§: ${report.summary.totalIndexes}Í∞ú`);
    console.log(`   ÌôúÏÑ± Ïù∏Îç±Ïä§: ${report.summary.activeIndexes}Í∞ú`);
    console.log(`   Ìö®Í≥ºÏ†Å Ïù∏Îç±Ïä§: ${report.summary.effectiveIndexes}Í∞ú`);
    console.log(`   Ïù∏Îç±Ïä§ ÌûàÌä∏Ïú®: ${report.summary.indexHitRate}%`);
    console.log(`   Ï¥ù Í≤ÄÏÇ¨ ÌöüÏàò: ${report.summary.totalChecks}Ìöå`);
    console.log(`   Ïä¨Î°úÏö∞ ÏøºÎ¶¨: ${report.summary.slowQueries}Í∞ú`);
    
    // Ï∂îÏ≤úÏÇ¨Ìï≠ ÏÉùÏÑ±
    this.generateRecommendations(report);
    
    return report;
  }

  /**
   * Ï∂îÏ≤úÏÇ¨Ìï≠ ÏÉùÏÑ±
   */
  generateRecommendations(report) {
    console.log('\nüí° Ï∂îÏ≤úÏÇ¨Ìï≠:');
    
    // ÎπÑÌö®Ïú®Ï†ÅÏù∏ Ïù∏Îç±Ïä§ ÏãùÎ≥Ñ
    const ineffectiveIndexes = report.indexDetails.filter(idx => 
      idx.effectiveness === 'POOR' || idx.effectiveness === 'FAIR'
    );
    
    if (ineffectiveIndexes.length > 0) {
      console.log('   üîß Îã§Ïùå Ïù∏Îç±Ïä§Îì§Ïùò ÏµúÏ†ÅÌôîÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§:');
      ineffectiveIndexes.forEach(idx => {
        console.log(`      - ${idx.name}: ${idx.effectiveness} (ÌèâÍ∑† ${Math.round(idx.avgPerformance)}ms)`);
        report.recommendations.push({
          type: 'OPTIMIZE_INDEX',
          index: idx.name,
          reason: `ÏÑ±Îä•Ïù¥ ${idx.effectiveness} ÏàòÏ§ÄÏûÖÎãàÎã§.`
        });
      });
    }
    
    // Ïä¨Î°úÏö∞ ÏøºÎ¶¨ ÎßéÏùÄ Í≤ΩÏö∞
    if (report.summary.slowQueries > 0) {
      console.log(`   ‚ö†Ô∏è ${report.summary.slowQueries}Í∞úÏùò Ïä¨Î°úÏö∞ ÏøºÎ¶¨Í∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.`);
      report.recommendations.push({
        type: 'INVESTIGATE_SLOW_QUERIES',
        count: report.summary.slowQueries,
        reason: 'Ï∂îÍ∞Ä Ïù∏Îç±Ïä§ÎÇò ÏøºÎ¶¨ ÏµúÏ†ÅÌôîÍ∞Ä ÌïÑÏöîÌï† Ïàò ÏûàÏäµÎãàÎã§.'
      });
    }
    
    // Ïù∏Îç±Ïä§ ÌûàÌä∏Ïú®Ïù¥ ÎÇÆÏùÄ Í≤ΩÏö∞
    if (report.summary.indexHitRate < 80) {
      console.log(`   üìä Ïù∏Îç±Ïä§ ÌûàÌä∏Ïú®Ïù¥ ${report.summary.indexHitRate}%Î°ú ÎÇÆÏäµÎãàÎã§.`);
      report.recommendations.push({
        type: 'IMPROVE_INDEX_USAGE',
        hitRate: report.summary.indexHitRate,
        reason: 'ÏøºÎ¶¨ Ìå®ÌÑ¥ Î∂ÑÏÑù Î∞è Ï∂îÍ∞Ä Ïù∏Îç±Ïä§ Í≤ÄÌÜ†Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'
      });
    }
    
    // Î™®Îì† Í≤ÉÏù¥ ÏñëÌò∏Ìïú Í≤ΩÏö∞
    if (report.recommendations.length === 0) {
      console.log('   ‚úÖ Î™®Îì† Ïù∏Îç±Ïä§Í∞Ä Ìö®Í≥ºÏ†ÅÏúºÎ°ú ÏûëÎèôÌïòÍ≥† ÏûàÏäµÎãàÎã§!');
      report.recommendations.push({
        type: 'EXCELLENT_PERFORMANCE',
        reason: 'ÌòÑÏû¨ Ïù∏Îç±Ïä§ ÏÑ§Ï†ïÏù¥ ÏµúÏ†ÅÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.'
      });
    }
  }

  /**
   * Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
   */
  async startContinuousMonitoring(intervalMinutes = 30) {
    console.log(`\nüîÑ Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë (${intervalMinutes}Î∂Ñ Í∞ÑÍ≤©)`);
    
    const monitoringInterval = setInterval(async () => {
      try {
        console.log('\n‚è∞ Ï†ïÍ∏∞ ÏÑ±Îä• Í≤ÄÏÇ¨ Ïã§Ìñâ...');
        
        await this.collectIndexUsageStats();
        const performanceResults = await this.runPerformanceTests();
        
        // ÏÑ±Îä• Ï†ÄÌïò Í∞êÏßÄ
        for (const result of performanceResults) {
          if (result.improvement && result.improvement.improvementPercent < -this.alertThresholds.performanceDegradation) {
            await this.alertSystem.sendAlert({
              type: 'PERFORMANCE_DEGRADATION',
              severity: 'WARNING',
              message: `ÏÑ±Îä• Ï†ÄÌïò Í∞êÏßÄ: ${result.name} (${Math.abs(result.improvement.improvementPercent)}% Ï†ÄÌïò)`,
              details: result
            });
          }
        }
        
        console.log('‚úÖ Ï†ïÍ∏∞ Í≤ÄÏÇ¨ ÏôÑÎ£å');
        
      } catch (error) {
        console.error('‚ùå Ï†ïÍ∏∞ Î™®ÎãàÌÑ∞ÎßÅ Ï§ë Ïò§Î•ò:', error.message);
      }
    }, intervalMinutes * 60 * 1000);
    
    // ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£åÏãú Ï†ïÎ¶¨
    process.on('SIGINT', () => {
      console.log('\nüõë Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÎã®...');
      clearInterval(monitoringInterval);
      this.disconnect();
      process.exit(0);
    });
    
    return monitoringInterval;
  }

  /**
   * ÏÑ±Îä• Î≥¥Í≥†ÏÑúÎ•º JSON ÌååÏùºÎ°ú Ï†ÄÏû•
   */
  async savePerformanceReport() {
    try {
      const report = this.generateIndexEffectivenessReport();
      
      const fs = require('fs').promises;
      const reportPath = `../docs/index_performance_report_${new Date().toISOString().split('T')[0]}.json`;
      
      await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
      console.log(`\nüìÑ ÏÑ±Îä• Î≥¥Í≥†ÏÑú Ï†ÄÏû•: ${reportPath}`);
      
      return reportPath;
      
    } catch (error) {
      console.error('‚ùå Î≥¥Í≥†ÏÑú Ï†ÄÏû• Ïã§Ìå®:', error.message);
      return null;
    }
  }
}

// Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
async function main() {
  const monitor = new IndexPerformanceMonitor();
  
  try {
    console.log('üöÄ Ïù∏Îç±Ïä§ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú ÏãúÏûë');
    
    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞
    if (!await monitor.connect()) {
      process.exit(1);
    }
    
    // Ïù∏Îç±Ïä§ ÏÇ¨Ïö©Î•† ÌÜµÍ≥Ñ ÏàòÏßë
    await monitor.collectIndexUsageStats();
    
    // ÏÑ±Îä• ÌÖåÏä§Ìä∏ Ïã§Ìñâ
    await monitor.runPerformanceTests();
    
    // Ìö®Í≥º Î∂ÑÏÑù Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    const report = monitor.generateIndexEffectivenessReport();
    
    // Î≥¥Í≥†ÏÑú Ï†ÄÏû•
    await monitor.savePerformanceReport();
    
    console.log('\nüéØ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å!');
    console.log('   - Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ: startContinuousMonitoring() Ìò∏Ï∂ú');
    console.log('   - Í∞úÎ≥Ñ ÌÖåÏä§Ìä∏: runPerformanceTests() Ìò∏Ï∂ú');
    console.log('   - Î≥¥Í≥†ÏÑú ÏÉùÏÑ±: generateIndexEffectivenessReport() Ìò∏Ï∂ú');
    
  } catch (error) {
    console.error('‚ùå Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú Ïã§Ìñâ Ï§ë Ïò§Î•ò:', error);
  } finally {
    await monitor.disconnect();
  }
}

// Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏßÅÏ†ë Ïã§ÌñâÎê† ÎïåÎßå main() Ìò∏Ï∂ú
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { IndexPerformanceMonitor, MONITORED_INDEXES, PERFORMANCE_TEST_QUERIES };
